name: Service Monitoring Deploy

on:
  push:
    branches: [main]
    # Avoid auto-deploys when only workflow files change.
    paths-ignore:
      - ".github/workflows/**"
  workflow_dispatch: {}

concurrency:
  group: service-monitoring-prod
  cancel-in-progress: false

jobs:
  test:
    runs-on: [self-hosted, pitchai-ci]
    steps:
      # Self-hosted runner + dockerized pytest: the container runs as root and can leave
      # behind root-owned files in the workspace (e.g. `.pytest_cache`), which then
      # breaks the next `actions/checkout` clean step. Pre-clean with sudo to keep
      # the runner from getting stuck.
      - name: Pre-clean workspace (avoid root-owned leftovers)
        run: |
          sudo rm -rf "$GITHUB_WORKSPACE"/* "$GITHUB_WORKSPACE"/.[!.]* "$GITHUB_WORKSPACE"/..?* || true

      - name: Checkout
        uses: actions/checkout@v4

      - name: Build test image
        run: docker build -t service-monitoring:ci .

      - name: Run tests (HTTP + Playwright UI)
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE:/work" \
            -w /work \
            service-monitoring:ci \
            sh -lc "pip install --no-cache-dir -r requirements-dev.txt && python -m pytest -o cache_dir=/tmp/pytest_cache"

  deploy-prod:
    runs-on: [self-hosted, pitchai-ci]
    needs: test
    steps:
      - name: Deploy to production (SSH + Docker)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HETZNER_HOST }}
          username: ${{ secrets.HETZNER_USER }}
          key: ${{ secrets.HETZNER_SSH_KEY }}
          port: 22
          script: |
            set -euo pipefail

            APP_NAME="service-monitoring"
            OLD_NAME="monitoring"
            REGISTRY_NAME="e2e-registry"
            RUNNER_NAME="e2e-runner"
            NET_NAME="pitchai-shared"
            IMAGE_SHA="service-monitoring:${{ github.sha }}"
            IMAGE_LATEST="service-monitoring:latest"

            echo "üöÄ Deploying ${APP_NAME} + ${REGISTRY_NAME} + ${RUNNER_NAME} @ ${{ github.sha }}"

            DEPLOY_DIR="/tmp/${APP_NAME}-deploy-${{ github.run_id }}-${{ github.run_attempt }}"
            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            echo "üì• Cloning repo..."
            git clone https://github.com/JoshuaSeth/pitchai-monitoring.git .
            git checkout ${{ github.sha }}

            echo "üåê Ensuring docker network exists: $NET_NAME"
            if ! docker network ls --format '{{.Name}}' | grep -qx "$NET_NAME"; then
              docker network create "$NET_NAME" >/dev/null
            fi

            stop_rm_if_exists() {
              local name="$1"
              if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
                echo "üõë Stopping existing container: $name"
                docker stop "$name" || true
                docker rm "$name" || true
              fi
            }

            if docker ps -a --format '{{.Names}}' | grep -qx "$OLD_NAME"; then
              old_image="$(docker inspect "$OLD_NAME" --format '{{.Config.Image}}' || true)"
              echo "Found legacy container '$OLD_NAME' image=$old_image"
              if [[ "$old_image" == monitoring-system:* || "$old_image" == monitoring-system || "$old_image" == service-monitoring:* || "$old_image" == service-monitoring ]]; then
                echo "üõë Stopping legacy container: $OLD_NAME"
                docker stop "$OLD_NAME" || true
                docker rm "$OLD_NAME" || true
              else
                echo "‚ö†Ô∏è Refusing to stop '$OLD_NAME' (unexpected image: $old_image)"
              fi
            fi

            stop_rm_if_exists "$APP_NAME"
            stop_rm_if_exists "$REGISTRY_NAME"
            stop_rm_if_exists "$RUNNER_NAME"

            echo "üî® Building image..."
            docker build -t "$IMAGE_SHA" -t "$IMAGE_LATEST" .

            echo "üì¶ Ensuring volumes exist..."
            docker volume create service-monitoring-state >/dev/null
            docker volume create e2e-registry-data >/dev/null
            docker volume create e2e-artifacts >/dev/null

            echo "üîê Ensuring E2E registry tokens exist..."
            SECRETS_DIR="${HOME}/service-monitoring"
            mkdir -p "$SECRETS_DIR"
            E2E_ENV_FILE="$SECRETS_DIR/e2e-registry.env"
            if [[ ! -f "$E2E_ENV_FILE" ]]; then
              echo "Generating new E2E registry tokens at $E2E_ENV_FILE"
              admin="$(python3 -c 'import secrets; print(secrets.token_urlsafe(48))')"
              monitor="$(python3 -c 'import secrets; print(secrets.token_urlsafe(48))')"
              runner="$(python3 -c 'import secrets; print(secrets.token_urlsafe(48))')"
              {
                echo "E2E_REGISTRY_ADMIN_TOKEN=${admin}"
                echo "E2E_REGISTRY_MONITOR_TOKEN=${monitor}"
                echo "E2E_REGISTRY_RUNNER_TOKEN=${runner}"
                echo "E2E_REGISTRY_DB_PATH=/data/e2e-registry.db"
                echo "E2E_ARTIFACTS_DIR=/artifacts"
                echo "E2E_TESTS_DIR=/data/e2e-tests"
                echo "E2E_REGISTRY_ALERTS_ENABLED=1"
                echo "E2E_REGISTRY_DISPATCH_ENABLED=1"
                echo "E2E_REGISTRY_STRICT_BASE_URL_POLICY=1"
                echo "E2E_REGISTRY_ALLOW_MONITORED_DOMAINS=1"
              } >"$E2E_ENV_FILE"
              chmod 600 "$E2E_ENV_FILE" || true
            fi
            # Backfill new required settings into an existing env file.
            if ! grep -qE '^E2E_TESTS_DIR=' "$E2E_ENV_FILE"; then
              echo "E2E_TESTS_DIR=/data/e2e-tests" >>"$E2E_ENV_FILE"
            fi
            if ! grep -qE '^E2E_REGISTRY_STRICT_BASE_URL_POLICY=' "$E2E_ENV_FILE"; then
              echo "E2E_REGISTRY_STRICT_BASE_URL_POLICY=1" >>"$E2E_ENV_FILE"
            fi
            if ! grep -qE '^E2E_REGISTRY_ALLOW_MONITORED_DOMAINS=' "$E2E_ENV_FILE"; then
              echo "E2E_REGISTRY_ALLOW_MONITORED_DOMAINS=1" >>"$E2E_ENV_FILE"
            fi
            E2E_MONITOR_TOKEN="$(grep -E '^E2E_REGISTRY_MONITOR_TOKEN=' "$E2E_ENV_FILE" | head -n1 | cut -d= -f2-)"
            if [[ -z "${E2E_MONITOR_TOKEN}" ]]; then
              echo "‚ùå Missing E2E_REGISTRY_MONITOR_TOKEN in $E2E_ENV_FILE"
              exit 1
            fi

            echo "üöÄ Starting e2e-registry..."
            docker run -d \
              --name "$REGISTRY_NAME" \
              --restart unless-stopped \
              --init \
              --network "$NET_NAME" \
              -p 127.0.0.1:8111:8111 \
              -v service-monitoring-state:/monitor_state:ro \
              -v e2e-registry-data:/data \
              -v e2e-artifacts:/artifacts \
              --env-file "$E2E_ENV_FILE" \
              -e SERVICE_MONITOR_STATE_PATH="/monitor_state/state.json" \
              -e TELEGRAM_BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}" \
              -e TELEGRAM_CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}" \
              -e PITCHAI_DISPATCH_BASE_URL="https://dispatch.pitchai.net" \
              -e PITCHAI_DISPATCH_TOKEN="${{ secrets.PITCHAI_DISPATCH_TOKEN }}" \
              "$IMAGE_SHA" \
              python -m e2e_registry.server

            echo "üöÄ Starting e2e-runner..."
            docker run -d \
              --name "$RUNNER_NAME" \
              --restart unless-stopped \
              --init \
              --shm-size 1g \
              --network "$NET_NAME" \
              -v e2e-artifacts:/artifacts \
              -v e2e-registry-data:/data:ro \
              --env-file "$E2E_ENV_FILE" \
              -e E2E_REGISTRY_BASE_URL="http://${REGISTRY_NAME}:8111" \
              -e E2E_RUNNER_POLL_SECONDS="5" \
              -e E2E_RUNNER_CONCURRENCY="1" \
              -e E2E_RUNNER_TRACE_ON_FAILURE="0" \
              "$IMAGE_SHA" \
              python -m e2e_runner.main

            echo "üöÄ Starting service-monitoring..."
            docker run -d \
              --name "$APP_NAME" \
              --restart unless-stopped \
              --init \
              --shm-size 1g \
              --network "$NET_NAME" \
              -v service-monitoring-state:/data \
              -v /var/run/docker.sock:/var/run/docker.sock \
              -v /var/log/nginx:/var/log/nginx:ro \
              -e TELEGRAM_BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}" \
              -e TELEGRAM_CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}" \
              -e PITCHAI_DISPATCH_BASE_URL="https://dispatch.pitchai.net" \
              -e PITCHAI_DISPATCH_TOKEN="${{ secrets.PITCHAI_DISPATCH_TOKEN }}" \
              -e STATE_PATH="/data/state.json" \
              -e E2E_REGISTRY_BASE_URL="http://${REGISTRY_NAME}:8111" \
              -e E2E_REGISTRY_MONITOR_TOKEN="${E2E_MONITOR_TOKEN}" \
              "$IMAGE_SHA"

            echo "‚è≥ Waiting for startup..."
            sleep 10

            for name in "$REGISTRY_NAME" "$RUNNER_NAME" "$APP_NAME"; do
              running="$(docker inspect "$name" --format '{{.State.Running}}')"
              if [[ "$running" != "true" ]]; then
                echo "‚ùå Container is not running: $name"
                docker logs "$name" --tail 200 || true
                exit 1
              fi
            done

            echo "‚úÖ Containers running"
            docker ps --filter "name=${APP_NAME}|${REGISTRY_NAME}|${RUNNER_NAME}"
            docker logs "$REGISTRY_NAME" --tail 40 || true
            docker logs "$RUNNER_NAME" --tail 40 || true
            docker logs "$APP_NAME" --tail 80 || true

            cd /
            rm -rf "$DEPLOY_DIR"
